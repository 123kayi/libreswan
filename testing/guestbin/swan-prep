#!/usr/bin/python
#
# This script is run by a VM host (eg "west") to prepare itself for testing
# It should be passed a testname as its onyl argument

import os,sys,socket,shutil,distutils.dir_util,commands
import pexpect, glob

try:
	import argparse
except ImportError , e:
        module = str(e)[16:]
        sys.exit("we requires the python argparse module")

ipv = 0
ipv6 = 0
parser = argparse.ArgumentParser(description='swan-prep arguments')
parser.add_argument('--testname', '-t', action='store', default='', help='The name of the test to prepapre')
parser.add_argument('--hostname', '-H', action='store', default='', help='The name of the host to prepare as')
# we should get this from the testparams.sh file?
parser.add_argument('--userland', '-u', action='store', default='libreswan', help='which userland to prepapre')
parser.add_argument('--x509', '-x', action='store_true',  help='create X509 NSS file by importing test certs')
parser.add_argument('--46', '--64', action='store_true', help='Do not disable IPv6. Default is disable IPv6 ', dest = 'ipv', default = False)
parser.add_argument('--6', action='store_true', help='Enable IPv6 and run - /etc/init.d/network restart', dest = 'ipv6', default = False)
args = parser.parse_args()

if args.hostname:
	hostname = args.hostname
	if hostname == "nic":
		# nothing to do, just stop
		sys.exit()
else:
	hostname = socket.gethostname()
if "." in hostname:
	hostname = hostname.split(".")[0]

if args.testname:
	#if os.path.isdir("/testing/pluto/%s"%args.testname):
	#	testname = args.testname
	#else:
	#	sys.exit("Unknown or bad testname '%s'"%args.testname)
	testname = args.testname
else:
	testpath = "/testing/pluto/%s"%os.path.basename(os.getcwd())
	testname = os.path.basename(testpath)
	if not os.path.isdir(testpath):
		sys.exit("testcase /testing/pluto/%s invalid - aborted"%testname)

# Setup pluto.log softlink
if hostname != "nic":
    if os.path.isfile("/tmp/pluto.log") or os.path.islink("/tmp/pluto.log"):
        os.unlink("/tmp/pluto.log")

    outputdir="/testing/pluto/%s/OUTPUT/"%testname
    if  not os.path.isdir(outputdir):
            os.mkdir(outputdir)
            os.chmod(outputdir, 0777)
    plutologfile="%s/%s.pluto.log"%(outputdir,hostname)
    os.symlink(plutologfile,"/tmp/pluto.log")
    f = open(plutologfile,'w')
    f.close()
    os.chmod(plutologfile, 0777)

if args.userland:
	if not args.userland in ( "libreswan","strongswan","racoon","shrew", "openswan"):
		sys.exit("swan-prep: unknown userland type '%s'"%args.userland)
	userland = args.userland
else:
	userland = "libreswan"

#print "swan-prep running on %s for test %s with userland %s"%(hostname,testname,userland)

# wipe any old configs in /etc/ipsec.*
if os.path.isfile("/etc/ipsec.conf"):
	os.unlink("/etc/ipsec.conf")
if os.path.isfile("/etc/ipsec.secrets"):
	os.unlink("/etc/ipsec.secrets")
if os.path.isdir("/etc/ipsec.d"):
	shutil.rmtree("/etc/ipsec.d")
	os.mkdir("/etc/ipsec.d")



if userland == "libreswan" or userland == "openswan" or userland == "strongswan":
	# copy in base configs

	# this brings in the nss *.db files that are path-specific - they have pathnames hardcoded inside the file
	#shutil.copytree("/testing/baseconfigs/%s/etc/ipsec.d"%hostname, "/etc/")
	distutils.dir_util.copy_tree("/testing/baseconfigs/%s/etc/ipsec.d"%hostname, "/etc/ipsec.d/")

	# fill in any missing dirs
	for dir in ( "/etc/ipsec.d/policies", "/etc/ipsec.d/cacerts", "/etc/ipsec.d/crls", "/etc/ipsec.d/certs", "/etc/ipsec.d/private"):
		if not os.path.isdir(dir):
			os.mkdir(dir)

	# test specific files
	ipsecconf = "/testing/pluto/%s/%s.conf"%(testname,hostname)
	ipsecsecrets = "/testing/pluto/%s/%s.secrets"%(testname,hostname)
	if not os.path.isfile(ipsecconf):
		ipsecconf = "/testing/baseconfigs/%s/etc/ipsec.conf"%hostname
	if not os.path.isfile(ipsecsecrets):
		ipsecsecrets = "/testing/baseconfigs/%s/etc/ipsec.secrets"%hostname

	shutil.copy(ipsecconf, "/etc/ipsec.conf")
	shutil.copy(ipsecsecrets,"/etc/ipsec.secrets")
	os.chmod("/etc/ipsec.secrets",0600)
    
	if not args.ipv:
		commands.getoutput("sysctl net.ipv6.conf.all.disable_ipv6=1")
		commands.getoutput("net.ipv6.conf.all.disable_ipv6=1")

	if args.ipv6:
		commands.getoutput("sysctl net.ipv6.conf.all.disable_ipv6=0")
		commands.getoutput("sysctl net.ipv6.conf.all.disable_ipv6=0")
		commands.getoutput("/etc/init.d/network restart")

	if args.x509:
		print "Preparing X.509 NSS files"
		# clean out old db files and generate new ones from scratch, does not support -w for password
		oldfiles = glob.glob("/etc/ipsec.d/*db")
		for oldfile in oldfiles:
			os.unlink(oldfile)
		cmd = "certutil -N -d /etc/ipsec.d"
		timer = 10
		child = pexpect.spawn(cmd)
		child.sendline ('')
		child.sendline ('')

		commands.getoutput("pk12util -i /testing/x509/pkcs12/mainca/%s.p12 -d /etc/ipsec.d -w /testing/x509/nss-pw"%hostname)
		# install all other public certs
		for certname in ( "west", "east", "road" ):
			if certname is not hostname:
				commands.getoutput("certutil -A -n %s -t 'P,u' -d /etc/ipsec.d/ -a -i /testing/x509/certs/%s.crt"%(certname,certname))
			

if userland == "strongswan":
	#  strongswan specific
	for dir in ( "/etc/ipsec.d/aacerts", "/etc/ipsec.d/ocspcerts"):
		os.mkdir(dir)

if userland == "racoon2" or userland == "racoon":
	# setup racoon
	# note: tests do this manual - needs to be merged in
	print "racoon setup needs to be pulled from individual tests into swan-prep"

if userland == "shrew":
	print "shrew not yet tested/integrated"

# final prep - this kills any running userland
output = commands.getoutput("ipsec stop")
# python has no pidof :/
pluto = commands.getoutput("pidof pluto")
charon = commands.getoutput("pidof charon")
shrew = commands.getoutput("pidof iked")
racoon = commands.getoutput("pidof racoon")

for daemon in ( pluto, charon, shrew, racoon ):
	pids = commands.getoutput("pidof %s"%daemon)
	if pids:
		for pid in pids.split():
			os.kill(int(pid),9)
for pidfile in ( "/var/run/pluto/pluto.pid", "/var/run/charon.pid", "/var/run/iked.pid","/var/run/racoon.pid"):
	if os.path.isfile(pidfile):
		os.unlink(pidfile)

# remove stacks so test can start the stack it needs.
commands.getoutput("ipsec _stackmanager stop")
