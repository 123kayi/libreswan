From 204095c082218c5f6db72917283e9d63e3ae12db Mon Sep 17 00:00:00 2001
From: Bart Trojanowski <bart@jukie.net>
Date: Mon, 31 May 2010 16:19:19 -0400
Subject: [PATCH] SAREF: implement IP_IPSEC_BINDREF

Add sockopt IP_IPSEC_BINDREF, which associates an IPsec SAref to an inet
socket.  The ref is used to seed the skb->sp->ref for each skb on that
connection, which will force packets out a specific klips SA.
---
 include/linux/in.h     |    1 +
 include/net/sock.h     |    2 +-
 include/net/xfrm.h     |   15 +++++++++++++++
 net/core/sock.c        |    3 +++
 net/ipv4/ip_sockglue.c |   12 ++++++++++--
 net/ipv4/tcp.c         |    3 +++
 6 files changed, 33 insertions(+), 3 deletions(-)

diff --git a/include/linux/in.h b/include/linux/in.h
index 5964f73..99112dd 100644
--- a/include/linux/in.h
+++ b/include/linux/in.h
@@ -77,6 +77,7 @@ struct in_addr {
 #define IP_PASSSEC	18
 #define IP_TRANSPARENT	19
 #define IP_IPSEC_REFINFO 22
+#define IP_IPSEC_BINDREF 23
 
 /* indicate this tree has been patched with the SAREF code */
 #define HAVE_IPSEC_SAREF 1
diff --git a/include/net/sock.h b/include/net/sock.h
index 9f96394..19e9caf 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -293,7 +293,7 @@ struct sock {
 	void			*sk_security;
 #endif
 	__u32			sk_mark;
-	/* XXX 4 bytes hole on 64 bit */
+	__u32			sk_saref;
 	void			(*sk_state_change)(struct sock *sk);
 	void			(*sk_data_ready)(struct sock *sk, int bytes);
 	void			(*sk_write_space)(struct sock *sk);
diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index 3300be1..a4e3341 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -939,6 +939,21 @@ secpath_put(struct sec_path *sp)
 
 extern struct sec_path *secpath_dup(struct sec_path *src);
 
+/*
+ * Attach IPsec SAref value to skb, if appropriate.
+ */
+static inline void skb_sec_assign_sk_saref(struct sk_buff *skb, struct sock *sk)
+{
+#if defined(CONFIG_XFRM)
+	if (sk->sk_saref) {
+		if (!skb->sp)
+			skb->sp = secpath_dup(NULL);
+		if (skb->sp)
+			skb->sp->ref = sk->sk_saref;
+	}
+#endif
+}
+
 static inline void
 secpath_reset(struct sk_buff *skb)
 {
diff --git a/net/core/sock.c b/net/core/sock.c
index 6605e75..cd7a1ae 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -1412,6 +1412,9 @@ struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
 				int npages;
 				int i;
 
+				/* associate the skb with the socket's SAref */
+				skb_sec_assign_sk_saref(skb, sk);
+
 				/* No pages, we're done... */
 				if (!data_len)
 					break;
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 79d6a65..99e2ec1 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -475,7 +475,8 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 	    optname == IP_MULTICAST_ALL ||
 	    optname == IP_MULTICAST_LOOP ||
 	    optname == IP_RECVORIGDSTADDR ||
-	    optname == IP_IPSEC_REFINFO) {
+	    optname == IP_IPSEC_REFINFO ||
+	    optname == IP_IPSEC_BINDREF) {
 		if (optlen >= sizeof(int)) {
 			if (get_user(val, (int __user *) optval))
 				return -EFAULT;
@@ -569,13 +570,15 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 		else
 			inet->cmsg_flags &= ~IP_CMSG_ORIGDSTADDR;
 		break;
-                        break;
 	case IP_IPSEC_REFINFO:
 		if (val)
 			inet->cmsg_flags |= IP_CMSG_IPSEC_REFINFO;
 		else
 			inet->cmsg_flags &= ~IP_CMSG_IPSEC_REFINFO;
 		break;
+	case IP_IPSEC_BINDREF:
+		sk->sk_saref = val;
+		break;
 	case IP_TOS:	/* This sets both TOS and Precedence */
 		if (sk->sk_type == SOCK_STREAM) {
 			val &= ~3;
@@ -990,6 +993,7 @@ int ip_setsockopt(struct sock *sk, int level,
 			optname != IP_IPSEC_POLICY &&
 			optname != IP_XFRM_POLICY &&
 			optname != IP_IPSEC_REFINFO &&
+			optname != IP_IPSEC_BINDREF &&
 			!ip_mroute_opt(optname)) {
 		lock_sock(sk);
 		err = nf_setsockopt(sk, PF_INET, optname, optval, optlen);
@@ -1020,6 +1024,7 @@ int compat_ip_setsockopt(struct sock *sk, int level, int optname,
 			optname != IP_IPSEC_POLICY &&
 			optname != IP_XFRM_POLICY &&
 			optname != IP_IPSEC_REFINFO &&
+			optname != IP_IPSEC_BINDREF &&
 			!ip_mroute_opt(optname)) {
 		lock_sock(sk);
 		err = compat_nf_setsockopt(sk, PF_INET, optname,
@@ -1102,6 +1107,9 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,
 	case IP_IPSEC_REFINFO:
 		val = (inet->cmsg_flags & IP_CMSG_IPSEC_REFINFO) != 0;
 		break;
+	case IP_IPSEC_BINDREF:
+		val = sk->sk_saref;
+		break;
 	case IP_RECVORIGDSTADDR:
 		val = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;
 		break;
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index f1813bc..73b3ce1 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -685,6 +685,9 @@ struct sk_buff *sk_stream_alloc_skb(struct sock *sk, int size, gfp_t gfp)
 	skb = alloc_skb_fclone(size + sk->sk_prot->max_header, gfp);
 	if (skb) {
 		if (sk_wmem_schedule(sk, skb->truesize)) {
+			/* associate the skb with the socket's SAref */
+			skb_sec_assign_sk_saref(skb, sk);
+
 			/*
 			 * Make sure that we have exactly size bytes
 			 * available to the caller, no more, no less.
-- 
1.7.0.2.g2b0b7e7

