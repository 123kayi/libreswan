*** udp.c.orig	2008-03-27 21:29:32.000000000 -0400
--- udp.c	2006-04-25 22:40:09.000000000 -0400
***************
*** 109,119 ****
--- 109,122 ----
  #include <net/inet_common.h>
  #include <net/checksum.h>
  #include <net/xfrm.h>
+ #include <net/xfrmudp.h>
  
  /*
   *	Snmp MIB for the UDP layer
   */
  
+ static xfrm4_rcv_encap_t xfrm4_rcv_encap_func;
+ 
  DEFINE_SNMP_STAT(struct udp_mib, udp_statistics) __read_mostly;
  
  struct hlist_head udp_hash[UDP_HTABLE_SIZE];
***************
*** 497,502 ****
--- 500,507 ----
  	int err;
  	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
  
+ 	memset(&ipc, 0, sizeof(ipc));
+ 
  	if (len > 0xFFFF)
  		return -EMSGSIZE;
  
***************
*** 882,887 ****
--- 887,928 ----
  	sk_common_release(sk);
  }
  
+ #if defined(CONFIG_XFRM) || defined(CONFIG_IPSEC_NAT_TRAVERSAL)
+ 
+ /* if XFRM isn't a module, then register it directly. */
+ #if 0 && !defined(CONFIG_XFRM_MODULE) && !defined(CONFIG_IPSEC_NAT_TRAVERSAL)
+ static xfrm4_rcv_encap_t xfrm4_rcv_encap_func = xfrm4_rcv_encap;
+ #else
+ static xfrm4_rcv_encap_t xfrm4_rcv_encap_func = NULL;
+ #endif
+ 
+ int udp4_register_esp_rcvencap(xfrm4_rcv_encap_t func
+ 			       , xfrm4_rcv_encap_t *oldfunc)
+ {
+   if(oldfunc != NULL) {
+     *oldfunc = xfrm4_rcv_encap_func;
+   }
+ 
+ #if 0
+   if(xfrm4_rcv_encap_func != NULL)
+     return -1;
+ #endif
+ 
+   xfrm4_rcv_encap_func = func;
+   return 0;
+ }
+ 
+ int udp4_unregister_esp_rcvencap(xfrm4_rcv_encap_t func)
+ {
+   if(xfrm4_rcv_encap_func != func)
+     return -1;
+ 
+   xfrm4_rcv_encap_func = NULL;
+   return 0;
+ }
+ #endif /* CONFIG_XFRM_MODULE || CONFIG_IPSEC_NAT_TRAVERSAL */
+ 
+ 
  /* return:
   * 	1  if the the UDP system should process it
   *	0  if we should drop this packet
***************
*** 889,897 ****
   */
  static int udp_encap_rcv(struct sock * sk, struct sk_buff *skb)
  {
! #ifndef CONFIG_XFRM
  	return 1; 
! #else
  	struct udp_sock *up = udp_sk(sk);
    	struct udphdr *uh = skb->h.uh;
  	struct iphdr *iph;
--- 930,938 ----
   */
  static int udp_encap_rcv(struct sock * sk, struct sk_buff *skb)
  {
! #if !defined(CONFIG_XFRM) && !defined(CONFIG_IPSEC_NAT_TRAVERSAL)
  	return 1; 
! #else /* either CONFIG_XFRM or CONFIG_IPSEC_NAT_TRAVERSAL */
  	struct udp_sock *up = udp_sk(sk);
    	struct udphdr *uh = skb->h.uh;
  	struct iphdr *iph;
***************
*** 903,913 ****
  
  	/* if we're overly short, let UDP handle it */
  	if (udpdata > skb->tail)
! 		return 1;
  
  	/* if this is not encapsulated socket, then just return now */
  	if (!encap_type)
! 		return 1;
  
  	len = skb->tail - udpdata;
  
--- 944,954 ----
  
  	/* if we're overly short, let UDP handle it */
  	if (udpdata > skb->tail)
! 		return 2;
  
  	/* if this is not encapsulated socket, then just return now */
  	if (!encap_type)
! 		return 3;
  
  	len = skb->tail - udpdata;
  
***************
*** 922,928 ****
  			len = sizeof(struct udphdr);
  		} else
  			/* Must be an IKE packet.. pass it through */
! 			return 1;
  		break;
  	case UDP_ENCAP_ESPINUDP_NON_IKE:
  		/* Check if this is a keepalive packet.  If so, eat it. */
--- 963,969 ----
  			len = sizeof(struct udphdr);
  		} else
  			/* Must be an IKE packet.. pass it through */
! 			return 4;
  		break;
  	case UDP_ENCAP_ESPINUDP_NON_IKE:
  		/* Check if this is a keepalive packet.  If so, eat it. */
***************
*** 935,941 ****
  			len = sizeof(struct udphdr) + 2 * sizeof(u32);
  		} else
  			/* Must be an IKE packet.. pass it through */
! 			return 1;
  		break;
  	}
  
--- 976,982 ----
  			len = sizeof(struct udphdr) + 2 * sizeof(u32);
  		} else
  			/* Must be an IKE packet.. pass it through */
! 			return 5;
  		break;
  	}
  
***************
*** 1010,1017 ****
  			return 0;
  		}
  		if (ret < 0) {
!  			/* process the ESP packet */
!  			ret = xfrm4_rcv_encap(skb, up->encap_type);
  			return -ret;
  		}
  		/* FALLTHROUGH -- it's a UDP Packet */
--- 1051,1063 ----
  			return 0;
  		}
  		if (ret < 0) {
!  			if(xfrm4_rcv_encap_func != NULL) {
!  			  ret = (*xfrm4_rcv_encap_func)(skb, up->encap_type);
!  			  UDP_INC_STATS_BH(UDP_MIB_INDATAGRAMS);
!  			} else {
!  			  UDP_INC_STATS_BH(UDP_MIB_INERRORS);
!  			  ret = 1;
!  			}
  			return -ret;
  		}
  		/* FALLTHROUGH -- it's a UDP Packet */
***************
*** 1133,1139 ****
  		return udp_v4_mcast_deliver(skb, uh, saddr, daddr);
  
  	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
- 
  	if (sk != NULL) {
  		int ret = udp_queue_rcv_skb(sk, skb);
  		sock_put(sk);
--- 1179,1184 ----
***************
*** 1558,1560 ****
--- 1603,1610 ----
  EXPORT_SYMBOL(udp_proc_unregister);
  #endif
  
+ #if defined(CONFIG_IPSEC_NAT_TRAVERSAL)
+ EXPORT_SYMBOL(udp4_register_esp_rcvencap);
+ EXPORT_SYMBOL(udp4_unregister_esp_rcvencap);
+ #endif
+ 
