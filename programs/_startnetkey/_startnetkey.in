#!/bin/sh
# Netkey startup script
# Copyright (C) 2007 Ken Bantoft
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

me='ipsec _startnetkey'		# for messages

modules=/proc/modules
# full rp_filter path is $rpfilter1/interface/$rpfilter2
rpfilter1=/proc/sys/net/ipv4/conf
rpfilter2=rp_filter
# %unchanged or setting (0, 1, or 2)
rpfiltercontrol=0
kamepfkey=/proc/net/pfkey
bareversion=`uname -r | sed -e 's/\.nptl//' | sed -e 's/^\(2\.[0-9]\.[1-9][0-9]*-[1-9][0-9]*\(\.[0-9][0-9]*\)*\(\.x\)*\).*$/\1/'`

info=/dev/null
log=daemon.error
for dummy
do
	case "$1" in
	--log)		log="$2" ; shift	;;
	--info)		info="$2" ; shift	;;
	--debug)	debug="$2" ; shift	;;
	--omtu)		omtu="$2" ; shift	;;
	--fragicmp)	fragicmp="$2" ; shift	;;
	--hidetos)	hidetos="$2" ; shift	;;
	--rpfilter)	rpfiltercontrol="$2" ; shift	;;
	--)	shift ; break	;;
	-*)	echo "$me: unknown option \`$1'" >&2 ; exit 2	;;
	*)	break	;;
	esac
	shift
done


logger -p $log -t ipsec_setup "Using NETKEY/2.6 stack"



# Code to determine default route on Linux, taken from _startklips 
defaultinterface() {
	phys=`netstat -nr |
		awk '$1 == "0.0.0.0" && $3 == "0.0.0.0" { print $NF; exit 0 }'`
	if test " $phys" = " "
	then
		echo "no default route, %defaultroute cannot cope!!!"
		exit 1
	fi
        addr=
        eval `ifconfig $phys |
                awk '$1 == "inet" && $2 ~ /^addr:/ && $NF ~ /^Mask:/ {
                        gsub(/:/, " ", $0)
                        print "addr=" $3
                        other = $5
                        if ($4 == "Bcast")
                                print "type=broadcast"
                        else if ($4 == "P-t-P")
                                print "type=pointopoint"
                        else if (NF == 5) {
                                print "type="
                                other = ""
                        } else
                                print "type=unknown"
                        print "otheraddr=" other
                        print "mask=" $NF
                }'`
        if test " $addr" = " "
        then
                echo "unable to determine address of \`$phys'"
                exit 1
        fi


	nexthop=`netstat -nr |
		awk '$1 == "0.0.0.0" && $3 == "0.0.0.0" { print $2; exit 0 }'` 

	(
	echo "defaultroutephys=$phys"
        echo "defaultrouteaddr=$addr"
		if test " $2" = " 0.0.0.0"
                then
                	# this happens on people with ppp interfaces with 'route add default dev ppp0'.
                        echo "defaultroutenexthop=%direct"
                else
                        echo "defaultroutenexthop=$nexthop"
                fi
                ) >>$info
}

# log only to syslog, not to stdout/stderr
logonly() {
	logger -p $log -t ipsec_setup
}


# main line

	# Go find us a default Interface
 	defaultinterface;

	if test -f $modules
	then
		modprobe -qv af_key
		modprobe -qv ah4
		modprobe -qv esp4
		modprobe -qv ipcomp
		#  xfrm4_tunnel is needed by ipip and ipcomp
		modprobe -qv xfrm4_tunnel
		# xfrm_user contains netlink support for IPsec 
		modprobe -qv xfrm_user

		echo Trying hardware random, this may fail, which is okay.
		modprobe -qv hw_random 2>/dev/null

		# padlock must load before aes module
		echo Trying VIA padlock driver, this may fail, which is okay.
		modprobe -qv padlock 2>/dev/null

		# load the most common ciphers/algo's
		modprobe -qv sha1
		modprobe -qv md5
		modprobe -qv des
		modprobe -qv aes
	fi


	if ip xfrm state > /dev/null 2>&1
	then
		ip xfrm state flush
		ip xfrm policy flush
	elif type setkey > /dev/null 2>&1
	then
	 	# Check that the setkey command is available.
         	setkeycmd= 	 
         	PATH=$PATH:/usr/local/sbin 	 
         	for dir in `echo $PATH | tr ':' ' '` 	 
         	do 	 
                	if test -f $dir/setkey -a -x $dir/setkey 	 
                 	then
                         	setkeycmd=$dir/setkey
                         	break                   # NOTE BREAK OUT 
                	fi
         	done
        	$setkeycmd -F
        	$setkeycmd -FP
	else
	
        	echo "WARNING: cannot flush state/policy database -- \`$1'. Install a newer version of iproute/iproute2 or install the ipsec-tools package to obtain the setkey command." |
                	logger -s -p daemon.error -t ipsec_setup
	fi


exit 0
