#!/bin/sh
# Netkey startup script
# Copyright (C) 2007 Ken Bantoft <ken@xelerance.com>
# Copyright (C) 2007 - 2008 Paul Wouters <paul@xelerance.com>
# Copyright (C) 2008-2011 Tuomo Soini <tis@foobar.fi>
# Copyright (C) 2008-2012 Paul Wouters <paul@libreswan.org>
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#


kamepfkey=/proc/net/pfkey
ipsecpfkey=/proc/net/ipsec/version

action="$1"

if [ $action = "stop" ]
then
	# unload either stack - the user might have changed protostack=
	if [ -f $kamepfkey ]
	then
		# netkey stack found, let's unload - does this cause false positive for inline built?
                for mod in ipcomp ipcomp6 xfrm6_tunnel xfrm6_mode_tunnel xfrm6_mode_beet xfrm6_mode_ro \
                        xfrm6_mode_transport xfrm4_mode_transport xfrm4_mode_tunnel \
                        xfrm4_tunnel xfrm4_mode_beet esp4 esp6 ah4 ah6 af_key xfrm_user
                   do
                        # echo -n "$mod "
                        rmmod $mod 2> /dev/null
                   done
                echo
		if [ -f $kamepfkey -o -n '`lsmod | grep "^esp"`' ]
		then
			echo "FAILURE to unload NETKEY modules"
                	exit 1
		fi
	fi
	if [ -f $ipsecpfkey ]
	then
		echo "Warning: found KLIPS/MAST stack loaded"
		echo -n "Trying to unload KLIPS/MAST module..."
		rmmod ipsec 2> /dev/null
		if [ -f $ipsecpfkey ]
		then
			echo "FAILURE to unload KLIPS/MAST module"
                	exit 1
        	fi
		echo
	fi

elif [ $action = "start" ]
then
	if [ -f $ipsecpfkey ]
	then
		echo "Warning: found KLIPS/MAST stack loaded"
		echo -n "Trying to unload KLIPS/MAST module..."
		rmmod ipsec 2> /dev/null
		if [ -f $ipsecpfkey ]
		then
			echo "FAILURE to unload KLIPS/MAST module"
                	exit 1
        	fi
		echo
        fi

	# Test if we had any remnant policies from previous (hung) netkey modules
	ip xfrm state > /dev/null 2>&1
	RETVAL=$?
	if [ $RETVAL -ne 0 ]
	then
		echo "Found existing NETKEY/XFRM state - flushing"
		ip xfrm state flush
		ip xfrm policy flush
	fi

	if test -f /proc/modules
	then
		# load hardware random related modules - some changed names over time
		@MODPROBE@ hw_random 2>/dev/null
		@MODPROBE@ hwrng 2>/dev/null
		@MODPROBE@ virtio-rng 2>/dev/null
		@MODPROBE@ amd-rng 2>/dev/null
		@MODPROBE@ intel-rng 2>/dev/null
		@MODPROBE@ geode-rng 2>/dev/null
		# @MODPROBE@ timeriomem-rng 2>/dev/null

		# load all NETKEY modules
		for mod in ipcomp6 ipcomp xfrm6_tunnel xfrm6_mode_tunnel xfrm6_mode_beet xfrm6_mode_ro \
			xfrm6_mode_transport xfrm4_mode_transport xfrm4_mode_tunnel \
			xfrm4_tunnel xfrm4_mode_beet esp4 esp6 ah4 ah6 af_key
		   do
			# echo -n "$mod "
			@MODPROBE@ $mod 2> /dev/null
		   done

		# xfrm_user is the old name for xfrm4_tunnel - backwards compatibility
		@MODPROBE@ xfrm_user 2> /dev/null

		# padlock must load before aes module - though does not exist on newer kernels
		# padlock-aes must load before padlock-sha for some reason
		@MODPROBE@ padlock 2>/dev/null
		@MODPROBE@ padlock-aes 2>/dev/null
		@MODPROBE@ padlock-sha 2>/dev/null

		# load the most common ciphers/algo's
		# aes-x86_64 has higher priority in via crypto api
		for crypto in aesni_intel es-x86_64 geode-aes aes aes_generic des sha512 sha256 md5 cbc \
			    xcbc ecb twofish blowfish serpent ccm gcm ctr cts deflate cast5 cast6 lzo \
			    sha256_generic sha512_generic camellia
		   do
			# echo -n "$crypto "
			@MODPROBE@ $crypto 2> /dev/null
		   done
	fi
else
	echo "ipsec _startnetkey: unknown action '$action' - only 'start' and 'stop' are supported"
	exit 10
fi

exit 0
